# Sep 29
## Performance Measure
- Complete           (guarunteed to find a solution)
- Optimal            (finds the best solution)
- Time Complexity    (speed of the alg)
- Space Complexity   (memory  needed by the alg)

## Complexity Metrics
- `b`(branching factor) - maximum number of successors each node may have
    - a binary tree (b=2)
    - missionaries/cannibals (b=5, 5 actions) (row 2M, row 2C, row 1M 1C, row 1M, row 1C)
- `d`(depth) - depth of the shallowest goal
- `m`(maximum length) - max length of any path in the state space

```
            O
           / \
          O   \
         / \   \
        O   O   O
               / \
              O   O
             / \
            O   O
```
m=3
d=4

## Terminology
### Expanding a node (state)
- this means we are applying the successor function to a node
```
               (3 3 T)
           /      |        \
    (3 1 Nil)  (2 2 Nil)  (3 2 Nil)
```
- <u>known state</u>
    - a state that has already been generated by a successor function

### Implementation
- maintain two lists 
  1. closed list - all nodes that have already been expanded **avoids duplication of work**
  2. open list   - all nodes that have not been expanded/visited


### Missionaries/Cannibals
1. 
    - Open: (3 3 t)
    - Closed: Nil
2.
    - Open: (3 2 nil) (2 2 nil) (3 1 nil)
    - Closed: (3 3 t)

## Breadth First Search (BFS)
![BST](/bst.png)
- maintain the open list as a queue
- enqueue nodes into open list
- analyze that node, then put it into closed list

- Complete? Yes (it visits every node)
- Optimal?  Yes (it encounters the shallowest goal first)
- Time Complexity? O(b^(d+1))
- Space Complexity? O(b^(d+1))

*Note*: BFS is a search for the cautious. It is guarunteed to find the goal, and the optimal one. But it searches all nodes up to the goal.


## Uniform Cost Search
![BST](/bst2.png)
- we have a cost (weight) associated to reach each goal

| Iteration | Closed List | Frontier                |
| ----      | ----        | ----                    |
| 0         |             | A0                      |
| 1         | A0          | C2 B3                   |
| 2         | A0 C2       | B3 I(2+1) G(2+2) H(2+4) |
| 3         | A0 C2 B3    | I3 G4 E4 E5 H6          |

Complete? Yes
Optimal? Yes
Time complexity? O(b^(c*/eps))
Space complexity? O(b^(c*/eps))

- `c*` is the cost of the optimal solution
- `esp` is minimum action cost


## Depth First Search
- the open list is a stack
- "a search for the brave"
![BST](/bst2.png)

| Iteration | Closed List | Frontier                |
| ----      | ----        | ----                    |
| 0         |             | A                       |
| 1         | A           | B C                     |
| 2         | A B         | D E F C                 |
| 3         | A B D       | J E F C                 |
| 4         | A B D J     | N E F C                 |
| 5         | A B D J N   | P E F C                 |

Complete: the leftmost tree is infinite, so not complete
Optimal:  no
Time:      O(b^m)
Space:     O(bm)

- `m` is the maximum length of any path

- DFS will always find the solution with a better time complexity


## Depth Limited Search
Same as DFS with a predetermined cutoff depth, l
- terminate once all nodes at level l are generated
![BST](/bst2.png)
  
| Iteration | Closed List | Frontier                |
| ----      | ----        | ----                    |
| 0         |             | A                       |
| 1         | A           |                         |
| 1         | A           | B D                     |
| 1         | A B         | D                     |
| 1         | A B D       | E F                 |
| 1         | A B D E F   | C                   |
| 1         | A B D E F C |                     |

Complete:         no. DFS Limited doesnt guaruntee you find something
Optimal:          no. If its not complete it can't be optimal
Time Complexity:  O(b^l)
Space Complexity: O(bl)


## Iterative Deepening
- "big gun" search of AI state space search
- depth limit with increasing limits


Complete: yes, just a breadth first search with a restriction (eliminates infinite traversal)
Optimal: yes, it will find the goal node first
Time: O(b^d)
Space: O(bd)

**This is the ideal search, though more work to implement**


## Bidirectional Search
Two searches: one from the start, and one from the goal

For the cannibal thing:
- start: (3 3 t)
- goal (0 0 nil)

Often BFS both ways or BFS/DFS combo

For BFS both ways
Complete? Yes
Optimal? Yes
Time: O(b^(d/2))
Space: O(b^(d/2))
